// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import "testing"

// This test suite runs each operation test in parallel.
// Example, if your database has 3 tables, the suite will run:
// table1, table2 and table3 Delete in parallel
// table1, table2 and table3 Insert in parallel, and so forth.
// It does NOT run each operation group in parallel.
// Separating the tests thusly grants avoidance of Postgres deadlocks.
func TestParent(t *testing.T) {
	t.Run("Equities", testEquities)
	t.Run("Institutions", testInstitutions)
	t.Run("InstitutionRoles", testInstitutionRoles)
	t.Run("Instruments", testInstruments)
	t.Run("InstrumentClasses", testInstrumentClasses)
	t.Run("InstrumentJsons", testInstrumentJsons)
	t.Run("InstrumentSources", testInstrumentSources)
}

func TestDelete(t *testing.T) {
	t.Run("Equities", testEquitiesDelete)
	t.Run("Institutions", testInstitutionsDelete)
	t.Run("InstitutionRoles", testInstitutionRolesDelete)
	t.Run("Instruments", testInstrumentsDelete)
	t.Run("InstrumentClasses", testInstrumentClassesDelete)
	t.Run("InstrumentJsons", testInstrumentJsonsDelete)
	t.Run("InstrumentSources", testInstrumentSourcesDelete)
}

func TestQueryDeleteAll(t *testing.T) {
	t.Run("Equities", testEquitiesQueryDeleteAll)
	t.Run("Institutions", testInstitutionsQueryDeleteAll)
	t.Run("InstitutionRoles", testInstitutionRolesQueryDeleteAll)
	t.Run("Instruments", testInstrumentsQueryDeleteAll)
	t.Run("InstrumentClasses", testInstrumentClassesQueryDeleteAll)
	t.Run("InstrumentJsons", testInstrumentJsonsQueryDeleteAll)
	t.Run("InstrumentSources", testInstrumentSourcesQueryDeleteAll)
}

func TestSliceDeleteAll(t *testing.T) {
	t.Run("Equities", testEquitiesSliceDeleteAll)
	t.Run("Institutions", testInstitutionsSliceDeleteAll)
	t.Run("InstitutionRoles", testInstitutionRolesSliceDeleteAll)
	t.Run("Instruments", testInstrumentsSliceDeleteAll)
	t.Run("InstrumentClasses", testInstrumentClassesSliceDeleteAll)
	t.Run("InstrumentJsons", testInstrumentJsonsSliceDeleteAll)
	t.Run("InstrumentSources", testInstrumentSourcesSliceDeleteAll)
}

func TestExists(t *testing.T) {
	t.Run("Equities", testEquitiesExists)
	t.Run("Institutions", testInstitutionsExists)
	t.Run("InstitutionRoles", testInstitutionRolesExists)
	t.Run("Instruments", testInstrumentsExists)
	t.Run("InstrumentClasses", testInstrumentClassesExists)
	t.Run("InstrumentJsons", testInstrumentJsonsExists)
	t.Run("InstrumentSources", testInstrumentSourcesExists)
}

func TestFind(t *testing.T) {
	t.Run("Equities", testEquitiesFind)
	t.Run("Institutions", testInstitutionsFind)
	t.Run("InstitutionRoles", testInstitutionRolesFind)
	t.Run("Instruments", testInstrumentsFind)
	t.Run("InstrumentClasses", testInstrumentClassesFind)
	t.Run("InstrumentJsons", testInstrumentJsonsFind)
	t.Run("InstrumentSources", testInstrumentSourcesFind)
}

func TestBind(t *testing.T) {
	t.Run("Equities", testEquitiesBind)
	t.Run("Institutions", testInstitutionsBind)
	t.Run("InstitutionRoles", testInstitutionRolesBind)
	t.Run("Instruments", testInstrumentsBind)
	t.Run("InstrumentClasses", testInstrumentClassesBind)
	t.Run("InstrumentJsons", testInstrumentJsonsBind)
	t.Run("InstrumentSources", testInstrumentSourcesBind)
}

func TestOne(t *testing.T) {
	t.Run("Equities", testEquitiesOne)
	t.Run("Institutions", testInstitutionsOne)
	t.Run("InstitutionRoles", testInstitutionRolesOne)
	t.Run("Instruments", testInstrumentsOne)
	t.Run("InstrumentClasses", testInstrumentClassesOne)
	t.Run("InstrumentJsons", testInstrumentJsonsOne)
	t.Run("InstrumentSources", testInstrumentSourcesOne)
}

func TestAll(t *testing.T) {
	t.Run("Equities", testEquitiesAll)
	t.Run("Institutions", testInstitutionsAll)
	t.Run("InstitutionRoles", testInstitutionRolesAll)
	t.Run("Instruments", testInstrumentsAll)
	t.Run("InstrumentClasses", testInstrumentClassesAll)
	t.Run("InstrumentJsons", testInstrumentJsonsAll)
	t.Run("InstrumentSources", testInstrumentSourcesAll)
}

func TestCount(t *testing.T) {
	t.Run("Equities", testEquitiesCount)
	t.Run("Institutions", testInstitutionsCount)
	t.Run("InstitutionRoles", testInstitutionRolesCount)
	t.Run("Instruments", testInstrumentsCount)
	t.Run("InstrumentClasses", testInstrumentClassesCount)
	t.Run("InstrumentJsons", testInstrumentJsonsCount)
	t.Run("InstrumentSources", testInstrumentSourcesCount)
}

func TestHooks(t *testing.T) {
	t.Run("Equities", testEquitiesHooks)
	t.Run("Institutions", testInstitutionsHooks)
	t.Run("InstitutionRoles", testInstitutionRolesHooks)
	t.Run("Instruments", testInstrumentsHooks)
	t.Run("InstrumentClasses", testInstrumentClassesHooks)
	t.Run("InstrumentJsons", testInstrumentJsonsHooks)
	t.Run("InstrumentSources", testInstrumentSourcesHooks)
}

func TestInsert(t *testing.T) {
	t.Run("Equities", testEquitiesInsert)
	t.Run("Equities", testEquitiesInsertWhitelist)
	t.Run("Institutions", testInstitutionsInsert)
	t.Run("Institutions", testInstitutionsInsertWhitelist)
	t.Run("InstitutionRoles", testInstitutionRolesInsert)
	t.Run("InstitutionRoles", testInstitutionRolesInsertWhitelist)
	t.Run("Instruments", testInstrumentsInsert)
	t.Run("Instruments", testInstrumentsInsertWhitelist)
	t.Run("InstrumentClasses", testInstrumentClassesInsert)
	t.Run("InstrumentClasses", testInstrumentClassesInsertWhitelist)
	t.Run("InstrumentJsons", testInstrumentJsonsInsert)
	t.Run("InstrumentJsons", testInstrumentJsonsInsertWhitelist)
	t.Run("InstrumentSources", testInstrumentSourcesInsert)
	t.Run("InstrumentSources", testInstrumentSourcesInsertWhitelist)
}

// TestToOne tests cannot be run in parallel
// or deadlocks can occur.
func TestToOne(t *testing.T) {
	t.Run("EquityToInstrumentUsingInstrument", testEquityToOneInstrumentUsingInstrument)
	t.Run("EquityToInstrumentUsingPayCurrency", testEquityToOneInstrumentUsingPayCurrency)
	t.Run("EquityToInstrumentUsingExerciseCurrency", testEquityToOneInstrumentUsingExerciseCurrency)
	t.Run("EquityToInstrumentUsingCompanyCurrency", testEquityToOneInstrumentUsingCompanyCurrency)
	t.Run("InstitutionRoleToInstitutionUsingInstitution", testInstitutionRoleToOneInstitutionUsingInstitution)
	t.Run("InstitutionRoleToInstrumentUsingInstrument", testInstitutionRoleToOneInstrumentUsingInstrument)
	t.Run("InstrumentToInstrumentClassUsingInstrumentClass", testInstrumentToOneInstrumentClassUsingInstrumentClass)
	t.Run("InstrumentToInstrumentSourceUsingInstrumentSource", testInstrumentToOneInstrumentSourceUsingInstrumentSource)
	t.Run("InstrumentToInstrumentUsingCurrency", testInstrumentToOneInstrumentUsingCurrency)
	t.Run("InstrumentJSONToInstrumentUsingCurrency", testInstrumentJSONToOneInstrumentUsingCurrency)
}

// TestOneToOne tests cannot be run in parallel
// or deadlocks can occur.
func TestOneToOne(t *testing.T) {
	t.Run("InstrumentToEquityUsingEquity", testInstrumentOneToOneEquityUsingEquity)
}

// TestToMany tests cannot be run in parallel
// or deadlocks can occur.
func TestToMany(t *testing.T) {
	t.Run("InstitutionToInstitutionRoles", testInstitutionToManyInstitutionRoles)
	t.Run("InstrumentToPayCurrencyEquities", testInstrumentToManyPayCurrencyEquities)
	t.Run("InstrumentToExerciseCurrencyEquities", testInstrumentToManyExerciseCurrencyEquities)
	t.Run("InstrumentToCompanyCurrencyEquities", testInstrumentToManyCompanyCurrencyEquities)
	t.Run("InstrumentToInstitutionRoles", testInstrumentToManyInstitutionRoles)
	t.Run("InstrumentToCurrencyInstruments", testInstrumentToManyCurrencyInstruments)
	t.Run("InstrumentToCurrencyInstrumentJsons", testInstrumentToManyCurrencyInstrumentJsons)
	t.Run("InstrumentClassToInstruments", testInstrumentClassToManyInstruments)
	t.Run("InstrumentSourceToInstruments", testInstrumentSourceToManyInstruments)
}

// TestToOneSet tests cannot be run in parallel
// or deadlocks can occur.
func TestToOneSet(t *testing.T) {
	t.Run("EquityToInstrumentUsingInstrument", testEquityToOneSetOpInstrumentUsingInstrument)
	t.Run("EquityToInstrumentUsingPayCurrency", testEquityToOneSetOpInstrumentUsingPayCurrency)
	t.Run("EquityToInstrumentUsingExerciseCurrency", testEquityToOneSetOpInstrumentUsingExerciseCurrency)
	t.Run("EquityToInstrumentUsingCompanyCurrency", testEquityToOneSetOpInstrumentUsingCompanyCurrency)
	t.Run("InstitutionRoleToInstitutionUsingInstitution", testInstitutionRoleToOneSetOpInstitutionUsingInstitution)
	t.Run("InstitutionRoleToInstrumentUsingInstrument", testInstitutionRoleToOneSetOpInstrumentUsingInstrument)
	t.Run("InstrumentToInstrumentClassUsingInstrumentClass", testInstrumentToOneSetOpInstrumentClassUsingInstrumentClass)
	t.Run("InstrumentToInstrumentSourceUsingInstrumentSource", testInstrumentToOneSetOpInstrumentSourceUsingInstrumentSource)
	t.Run("InstrumentToInstrumentUsingCurrency", testInstrumentToOneSetOpInstrumentUsingCurrency)
	t.Run("InstrumentJSONToInstrumentUsingCurrency", testInstrumentJSONToOneSetOpInstrumentUsingCurrency)
}

// TestToOneRemove tests cannot be run in parallel
// or deadlocks can occur.
func TestToOneRemove(t *testing.T) {
	t.Run("EquityToInstrumentUsingPayCurrency", testEquityToOneRemoveOpInstrumentUsingPayCurrency)
	t.Run("EquityToInstrumentUsingExerciseCurrency", testEquityToOneRemoveOpInstrumentUsingExerciseCurrency)
	t.Run("EquityToInstrumentUsingCompanyCurrency", testEquityToOneRemoveOpInstrumentUsingCompanyCurrency)
	t.Run("InstrumentToInstrumentUsingCurrency", testInstrumentToOneRemoveOpInstrumentUsingCurrency)
	t.Run("InstrumentJSONToInstrumentUsingCurrency", testInstrumentJSONToOneRemoveOpInstrumentUsingCurrency)
}

// TestOneToOneSet tests cannot be run in parallel
// or deadlocks can occur.
func TestOneToOneSet(t *testing.T) {
	t.Run("InstrumentToEquityUsingEquity", testInstrumentOneToOneSetOpEquityUsingEquity)
}

// TestOneToOneRemove tests cannot be run in parallel
// or deadlocks can occur.
func TestOneToOneRemove(t *testing.T) {}

// TestToManyAdd tests cannot be run in parallel
// or deadlocks can occur.
func TestToManyAdd(t *testing.T) {
	t.Run("InstitutionToInstitutionRoles", testInstitutionToManyAddOpInstitutionRoles)
	t.Run("InstrumentToPayCurrencyEquities", testInstrumentToManyAddOpPayCurrencyEquities)
	t.Run("InstrumentToExerciseCurrencyEquities", testInstrumentToManyAddOpExerciseCurrencyEquities)
	t.Run("InstrumentToCompanyCurrencyEquities", testInstrumentToManyAddOpCompanyCurrencyEquities)
	t.Run("InstrumentToInstitutionRoles", testInstrumentToManyAddOpInstitutionRoles)
	t.Run("InstrumentToCurrencyInstruments", testInstrumentToManyAddOpCurrencyInstruments)
	t.Run("InstrumentToCurrencyInstrumentJsons", testInstrumentToManyAddOpCurrencyInstrumentJsons)
	t.Run("InstrumentClassToInstruments", testInstrumentClassToManyAddOpInstruments)
	t.Run("InstrumentSourceToInstruments", testInstrumentSourceToManyAddOpInstruments)
}

// TestToManySet tests cannot be run in parallel
// or deadlocks can occur.
func TestToManySet(t *testing.T) {
	t.Run("InstrumentToPayCurrencyEquities", testInstrumentToManySetOpPayCurrencyEquities)
	t.Run("InstrumentToExerciseCurrencyEquities", testInstrumentToManySetOpExerciseCurrencyEquities)
	t.Run("InstrumentToCompanyCurrencyEquities", testInstrumentToManySetOpCompanyCurrencyEquities)
	t.Run("InstrumentToCurrencyInstruments", testInstrumentToManySetOpCurrencyInstruments)
	t.Run("InstrumentToCurrencyInstrumentJsons", testInstrumentToManySetOpCurrencyInstrumentJsons)
}

// TestToManyRemove tests cannot be run in parallel
// or deadlocks can occur.
func TestToManyRemove(t *testing.T) {
	t.Run("InstrumentToPayCurrencyEquities", testInstrumentToManyRemoveOpPayCurrencyEquities)
	t.Run("InstrumentToExerciseCurrencyEquities", testInstrumentToManyRemoveOpExerciseCurrencyEquities)
	t.Run("InstrumentToCompanyCurrencyEquities", testInstrumentToManyRemoveOpCompanyCurrencyEquities)
	t.Run("InstrumentToCurrencyInstruments", testInstrumentToManyRemoveOpCurrencyInstruments)
	t.Run("InstrumentToCurrencyInstrumentJsons", testInstrumentToManyRemoveOpCurrencyInstrumentJsons)
}

func TestReload(t *testing.T) {
	t.Run("Equities", testEquitiesReload)
	t.Run("Institutions", testInstitutionsReload)
	t.Run("InstitutionRoles", testInstitutionRolesReload)
	t.Run("Instruments", testInstrumentsReload)
	t.Run("InstrumentClasses", testInstrumentClassesReload)
	t.Run("InstrumentJsons", testInstrumentJsonsReload)
	t.Run("InstrumentSources", testInstrumentSourcesReload)
}

func TestReloadAll(t *testing.T) {
	t.Run("Equities", testEquitiesReloadAll)
	t.Run("Institutions", testInstitutionsReloadAll)
	t.Run("InstitutionRoles", testInstitutionRolesReloadAll)
	t.Run("Instruments", testInstrumentsReloadAll)
	t.Run("InstrumentClasses", testInstrumentClassesReloadAll)
	t.Run("InstrumentJsons", testInstrumentJsonsReloadAll)
	t.Run("InstrumentSources", testInstrumentSourcesReloadAll)
}

func TestSelect(t *testing.T) {
	t.Run("Equities", testEquitiesSelect)
	t.Run("Institutions", testInstitutionsSelect)
	t.Run("InstitutionRoles", testInstitutionRolesSelect)
	t.Run("Instruments", testInstrumentsSelect)
	t.Run("InstrumentClasses", testInstrumentClassesSelect)
	t.Run("InstrumentJsons", testInstrumentJsonsSelect)
	t.Run("InstrumentSources", testInstrumentSourcesSelect)
}

func TestUpdate(t *testing.T) {
	t.Run("Equities", testEquitiesUpdate)
	t.Run("Institutions", testInstitutionsUpdate)
	t.Run("InstitutionRoles", testInstitutionRolesUpdate)
	t.Run("Instruments", testInstrumentsUpdate)
	t.Run("InstrumentClasses", testInstrumentClassesUpdate)
	t.Run("InstrumentJsons", testInstrumentJsonsUpdate)
	t.Run("InstrumentSources", testInstrumentSourcesUpdate)
}

func TestSliceUpdateAll(t *testing.T) {
	t.Run("Equities", testEquitiesSliceUpdateAll)
	t.Run("Institutions", testInstitutionsSliceUpdateAll)
	t.Run("InstitutionRoles", testInstitutionRolesSliceUpdateAll)
	t.Run("Instruments", testInstrumentsSliceUpdateAll)
	t.Run("InstrumentClasses", testInstrumentClassesSliceUpdateAll)
	t.Run("InstrumentJsons", testInstrumentJsonsSliceUpdateAll)
	t.Run("InstrumentSources", testInstrumentSourcesSliceUpdateAll)
}

func TestUpsert(t *testing.T) {
	t.Run("Equities", testEquitiesUpsert)
	t.Run("Institutions", testInstitutionsUpsert)
	t.Run("InstitutionRoles", testInstitutionRolesUpsert)
	t.Run("Instruments", testInstrumentsUpsert)
	t.Run("InstrumentClasses", testInstrumentClassesUpsert)
	t.Run("InstrumentJsons", testInstrumentJsonsUpsert)
	t.Run("InstrumentSources", testInstrumentSourcesUpsert)
}
